use crate::ast::*;

grammar(tag: &mut ParserTag);

// Macros

CommaList<T>: Vec<T> = {
  <T> => vec![<>],
  <l:(<T> ",")+> <r:T?> => match r {
    None => l,
    Some(r) => {
      let mut l = l;
      l.push(r);
      l
    }
  },
};

CommaListOpt<T>: Vec<T> = { => Vec::new(), CommaList<T> };

MaybeScheme<T>: MaybeScheme<T> = {
  // TODO: this just ignores duplicate names
  "(" <on:CommaList<Var>> ")" <t:T> => MaybeScheme::Scheme(Scheme::generalize(t, on.into_iter().collect())),
  "(" "*" ")" <t:T> => MaybeScheme::generalize(t),
  T => MaybeScheme::Inst(<>),
};

// Nonterminals

pub Expr: Expr = {
  (<MaybeScheme<Statement>> ".")+ => Expr::Assert(<>),
  <Clause> "?" => Expr::Query(<>),
  <MaybeScheme<Value>> "<>" <MaybeScheme<Value>> => Expr::UnifyVal(<>),
  <MaybeScheme<App>> "<>" <MaybeScheme<App>> => Expr::UnifyApp(<>),
};

pub Statement: Statement = {
  <App> r":-|⊢" <Clause> => Statement::new(<>),
  <App> => Statement::fact(<>),
};

pub Clause: Clause = OrClause;

OrClause: Clause = {
  <l:OrClause> ";" <r:AndClause> => Clause::Or(Box::new(l), Box::new(r)),
  AndClause
};

AndClause: Clause = {
  <l:AndClause> "," <r:UnaryClause> => Clause::And(Box::new(l), Box::new(r)),
  UnaryClause,
};

UnaryClause: Clause = {
  r"~|¬" <UnaryClause> => Clause::Not(Box::new(<>)),
  PrimClause,
}

PrimClause: Clause = {
  App => Clause::App(<>),
  r":top|⊤" => Clause::Top,
  r":bot|⊥" => Clause::Bot,
  "(" <Clause> ")",
}

pub App: App = <Atom> "(" <CommaListOpt<Value>> ")" => tag.make_app(<>);

pub Value: Value = {
  Var => Value::Var(<>),
  Atom => Value::Atom(<>),
};

Var: Var = r"[\p{Lu}\p{Lt}][\p{L}\p{N}]*" => Var::Formal(<>.into());
Atom: String = r"[\p{Ll}\p{N}][\p{L}\p{N}]*" => <>.into();
