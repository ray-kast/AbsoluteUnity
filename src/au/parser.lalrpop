use crate::ast::*;

grammar(tag: &mut ParserTag);

// Macros

CommaList<T>: Vec<T> = {
  <T> => vec![<>],
  <l:(<T> ",")+> <r:T?> => match r {
    None => l,
    Some(r) => {
      let mut l = l;
      l.push(r);
      l
    }
  },
};

CommaListOpt<T>: Vec<T> = { => Vec::new(), CommaList<T> };

MaybeScheme<T>: MaybeScheme<T> = {
  "forall" <on:CommaList<Var>> "." <t:T> => MaybeScheme::Scheme(Scheme::generalize(t, on)),
  T => MaybeScheme::Inst(<>),
};

// Nonterminals

pub Expr: Expr = {
  <MaybeScheme<Statement>> "." => Expr::Assert(<>),
  <MaybeScheme<Statement>> "?" => Expr::Query(<>),
  <MaybeScheme<Value>> "<>" <MaybeScheme<Value>> => Expr::UnifyVal(<>),
  <MaybeScheme<App>> "<>" <MaybeScheme<App>> => Expr::UnifyApp(<>),
};

pub Statement: Statement = {
  <Clause> r":-|⊢" <Clause> => Statement::new(<>),
  <Clause> => Statement::assert(<>),
};

pub Clause: Clause = AnyClause;

AnyClause: Clause = {
  <l:(<AllClause> ";")+> <r:AllClause> => { let mut l = l; l.push(r); Clause::Any(l) },
  AllClause
};

AllClause: Clause = {
  <l:(<UnaryClause> ",")+> <r:UnaryClause> => { let mut l = l; l.push(r); Clause::All(l) },
  UnaryClause,
};

UnaryClause: Clause = {
  r"~|¬" <UnaryClause> => Clause::Not(Box::new(<>)),
  PrimClause,
}

PrimClause: Clause = {
  App => Clause::App(<>),
  r":top|⊤" => Clause::top(),
  r":bot|⊥" => Clause::bot(),
  "(" <Clause> ")",
}

pub App: App = <Atom> "(" <CommaListOpt<Value>> ")" => tag.make_app(<>);

pub Value: Value = {
  Var => Value::Var(<>),
  Atom => Value::Atom(<>),
};

Var: Var = r"[\p{Lu}\p{Lt}][\p{L}\p{N}]*" => Var::Formal(<>.into());
Atom: String = r"[\p{Ll}\p{N}][\p{L}\p{N}]*" => <>.into();
