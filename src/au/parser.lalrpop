use crate::ast::*;

grammar(tag: &mut ParserTag);

// Macros

CommaList<T>: Vec<T> = {
  <T> => vec![<>],
  <l:(<T> ",")+> <r:T?> => match r {
    None => l,
    Some(r) => {
      let mut l = l;
      l.push(r);
      l
    }
  },
};

CommaListOpt<T>: Vec<T> = { => Vec::new(), CommaList<T> };

MaybeScheme<T>: MaybeScheme<T> = {
  <t:T> => MaybeScheme::generalize(t),
};

ExplicitMaybeScheme<T>: MaybeScheme<T> = {
  // TODO: this just ignores duplicate names
  "[" <on:CommaList<Var>> "]" <t:T> => MaybeScheme::Scheme(Scheme::generalize(t, on.into_iter().collect())),
  "[" "]" <t:T> => MaybeScheme::generalize(t),
  T => MaybeScheme::Inst(<>),
};

// Nonterminals

pub Expr: Expr = {
  Input => Expr::Assert(<>.0),
  <Clause> "?" => Expr::Query(<>),
  <ExplicitMaybeScheme<Value>> "<>" <ExplicitMaybeScheme<Value>> => Expr::UnifyVal(<>),
  <ExplicitMaybeScheme<App>> "<>" <ExplicitMaybeScheme<App>> => Expr::UnifyApp(<>),
  "#" <ExplicitMaybeScheme<Value>> => Expr::PrintVal(<>),
  "#" <ExplicitMaybeScheme<Statement>> => Expr::PrintStmt(<>),
  "/e" => Expr::PrintEnv,
  "/r" => Expr::Reset,
};

pub Input: Input = {
  (<MaybeScheme<Statement>> ".")+ => Input(<>),
}

pub Statement: Statement = {
  <App> r":-|⊢" <Clause> => Statement::new(<>),
  <App> => Statement::fact(<>),
};

pub Clause: Clause = OrClause;

OrClause: Clause = {
  <l:OrClause> ";" <r:AndClause> => Clause::Or(Box::new(l), Box::new(r)),
  AndClause
};

AndClause: Clause = {
  <l:AndClause> "," <r:UnaryClause> => Clause::And(Box::new(l), Box::new(r)),
  UnaryClause,
};

UnaryClause: Clause = {
  r"~|¬" <UnaryClause> => Clause::Not(Box::new(<>)),
  PrimClause,
}

PrimClause: Clause = {
  App => Clause::App(<>),
  r":top|⊤" => Clause::Top,
  r":bot|⊥" => Clause::Bot,
  "(" <Clause> ")",
}

pub App: App = <Atom> "(" <CommaListOpt<Value>> ")" => tag.make_app(<>);

pub Value: Value = ListValue;

ListValue: Value = {
  List => Value::List(Box::new(<>)),
  TupleValue,
};

pub List: List = {
  <h:TupleValue> ":" "[" <v:Var> "]" => List::Cons(h, Tail::Open(v)),
  <h:TupleValue> ":" <l:List> => List::Cons(h, Tail::Close(Box::new(l))),
  "[" "]" => List::Nil,
}

TupleValue: Value = {
  Var => Value::Var(<>),
  Atom => Value::Atom(<>),
  "(" <CommaList<Value>> ")" => Value::Tuple(Tuple(<>)),
}

Var: Var = r"[\p{Lu}\p{Lt}][\p{L}\p{N}]*" => Var::Formal(<>.into());
Atom: String = r"[\p{Ll}\p{N}][\p{L}\p{N}]*" => <>.into();
